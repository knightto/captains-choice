import express from 'express';
import cors from 'cors';
import { v4 as uuidv4 } from 'uuid';
import db from './database.js';

const app = express();
const PORT = 3000;

app.use(cors());
app.use(express.json());

// ==================== EVENT ENDPOINTS ====================

// Get all events
app.get('/api/events', async (req, res) => {
  try {
    const events = await db.all('SELECT * FROM events ORDER BY created_at DESC');
    res.json(events);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get single event
app.get('/api/events/:id', async (req, res) => {
  try {
    const event = await db.get('SELECT * FROM events WHERE id = ?', [req.params.id]);
    if (!event) {
      return res.status(404).json({ error: 'Event not found' });
    }
    res.json(event);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create event
app.post('/api/events', async (req, res) => {
  try {
    const id = uuidv4();
    const event = { id, ...req.body };
    
    const columns = Object.keys(event).join(', ');
    const placeholders = Object.keys(event).map(() => '?').join(', ');
    const values = Object.values(event);
    
    await db.run(`INSERT INTO events (${columns}) VALUES (${placeholders})`, values);
    
    res.status(201).json(event);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Update event
app.put('/api/events/:id', async (req, res) => {
  try {
    const updates = { ...req.body, updated_at: new Date().toISOString() };
    const setClause = Object.keys(updates).map(key => `${key} = ?`).join(', ');
    const values = [...Object.values(updates), req.params.id];
    
    const result = await db.run(`UPDATE events SET ${setClause} WHERE id = ?`, values);
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Event not found' });
    }
    
    const event = await db.get('SELECT * FROM events WHERE id = ?', [req.params.id]);
    res.json(event);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Delete event
app.delete('/api/events/:id', async (req, res) => {
  try {
    const result = await db.run('DELETE FROM events WHERE id = ?', [req.params.id]);
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Event not found' });
    }
    
    res.json({ message: 'Event deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== TEAM ENDPOINTS ====================

// Get teams for an event
app.get('/api/events/:eventId/teams', async (req, res) => {
  try {
    const teams = await db.all('SELECT * FROM teams WHERE event_id = ? ORDER BY team_number', [req.params.eventId]);
    res.json(teams);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create team
app.post('/api/teams', async (req, res) => {
  try {
    const id = uuidv4();
    const team = { id, ...req.body };
    
    const columns = Object.keys(team).join(', ');
    const placeholders = Object.keys(team).map(() => '?').join(', ');
    const values = Object.values(team);
    
    await db.run(`INSERT INTO teams (${columns}) VALUES (${placeholders})`, values);
    
    res.status(201).json(team);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Update team
app.put('/api/teams/:id', async (req, res) => {
  try {
    const setClause = Object.keys(req.body).map(key => `${key} = ?`).join(', ');
    const values = [...Object.values(req.body), req.params.id];
    
    const result = await db.run(`UPDATE teams SET ${setClause} WHERE id = ?`, values);
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Team not found' });
    }
    
    const team = await db.get('SELECT * FROM teams WHERE id = ?', [req.params.id]);
    res.json(team);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Delete team
app.delete('/api/teams/:id', async (req, res) => {
  try {
    const result = await db.run('DELETE FROM teams WHERE id = ?', [req.params.id]);
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Team not found' });
    }
    
    res.json({ message: 'Team deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== PLAYER ENDPOINTS ====================

// Get players for an event
app.get('/api/events/:eventId/players', async (req, res) => {
  try {
    const players = await db.all('SELECT * FROM players WHERE event_id = ? ORDER BY last_name, first_name', [req.params.eventId]);
    res.json(players);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get players for a team
app.get('/api/teams/:teamId/players', async (req, res) => {
  try {
    const players = await db.all('SELECT * FROM players WHERE team_id = ?', [req.params.teamId]);
    res.json(players);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create player
app.post('/api/players', async (req, res) => {
  try {
    const id = uuidv4();
    const player = { id, ...req.body };
    
    const columns = Object.keys(player).join(', ');
    const placeholders = Object.keys(player).map(() => '?').join(', ');
    const values = Object.values(player);
    
    await db.run(`INSERT INTO players (${columns}) VALUES (${placeholders})`, values);
    
    res.status(201).json(player);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Update player
app.put('/api/players/:id', async (req, res) => {
  try {
    const setClause = Object.keys(req.body).map(key => `${key} = ?`).join(', ');
    const values = [...Object.values(req.body), req.params.id];
    
    const result = await db.run(`UPDATE players SET ${setClause} WHERE id = ?`, values);
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Player not found' });
    }
    
    const player = await db.get('SELECT * FROM players WHERE id = ?', [req.params.id]);
    res.json(player);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Delete player
app.delete('/api/players/:id', async (req, res) => {
  try {
    const result = await db.run('DELETE FROM players WHERE id = ?', [req.params.id]);
    
    if (result.changes === 0) {
      return res.status(404).json({ error: 'Player not found' });
    }
    
    res.json({ message: 'Player deleted successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== SCORING ENDPOINTS ====================

// Get scores for a team
app.get('/api/teams/:teamId/scores', async (req, res) => {
  try {
    const scores = await db.all('SELECT * FROM scores WHERE team_id = ? ORDER BY hole_number', [req.params.teamId]);
    res.json(scores);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create/update score
app.post('/api/scores', async (req, res) => {
  try {
    const id = uuidv4();
    const score = { id, ...req.body };
    
    const columns = Object.keys(score).join(', ');
    const placeholders = Object.keys(score).map(() => '?').join(', ');
    const values = Object.values(score);
    
    await db.run(`INSERT OR REPLACE INTO scores (${columns}) VALUES (${placeholders})`, values);
    
    res.status(201).json(score);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== SIDE GAMES ENDPOINTS ====================

// Get side game results for an event
app.get('/api/events/:eventId/side-games', async (req, res) => {
  try {
    const results = await db.all('SELECT * FROM side_game_results WHERE event_id = ?', [req.params.eventId]);
    res.json(results);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create side game result
app.post('/api/side-games', async (req, res) => {
  try {
    const id = uuidv4();
    const result = { id, ...req.body };
    
    const columns = Object.keys(result).join(', ');
    const placeholders = Object.keys(result).map(() => '?').join(', ');
    const values = Object.values(result);
    
    await db.run(`INSERT INTO side_game_results (${columns}) VALUES (${placeholders})`, values);
    
    res.status(201).json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== MULLIGAN ENDPOINTS ====================

// Get mulligans for a player
app.get('/api/players/:playerId/mulligans', async (req, res) => {
  try {
    const mulligans = await db.get('SELECT * FROM mulligans WHERE player_id = ?', [req.params.playerId]);
    res.json(mulligans);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Create/update mulligan record
app.post('/api/mulligans', async (req, res) => {
  try {
    const id = uuidv4();
    const mulligan = { id, ...req.body };
    
    const columns = Object.keys(mulligan).join(', ');
    const placeholders = Object.keys(mulligan).map(() => '?').join(', ');
    const values = Object.values(mulligan);
    
    await db.run(`INSERT OR REPLACE INTO mulligans (${columns}) VALUES (${placeholders})`, values);
    
    res.status(201).json(mulligan);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== DOCUMENT GENERATION ENDPOINTS ====================

// Generate event documents
app.get('/api/events/:id/documents/:type', async (req, res) => {
  try {
    const event = await db.get('SELECT * FROM events WHERE id = ?', [req.params.id]);
    if (!event) {
      return res.status(404).json({ error: 'Event not found' });
    }
    
    const { type } = req.params;
    let document = '';
    
    switch (type) {
      case 'summary':
        document = generateEventSummary(event);
        break;
      case 'rules':
        document = generateRulesDocument(event);
        break;
      case 'starter-script':
        document = generateStarterScript(event);
        break;
      case 'scorecard':
        document = generateScorecardTemplate(event);
        break;
      default:
        return res.status(400).json({ error: 'Invalid document type' });
    }
    
    res.json({ document });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Document generation helper functions
function generateEventSummary(event) {
  const isScramble = event.format === 'Captains Choice';
  
  return `
# ${event.name || 'Golf Outing'} - Event Summary

## Event Details
- **Course:** ${event.course_name || '[Course Name]'}, ${event.course_city || '[City]'}, ${event.course_state || '[State]'}
- **Date:** ${event.event_date || '[Date]'}
- **Start Time:** ${event.start_time || '[Time]'}
- **Format:** ${event.team_size ? event.team_size + '-man ' : ''}${event.format}
- **Start Type:** ${event.start_type}

## Format Overview
${isScramble ? 
  `This is a ${event.team_size}-person Captain's Choice (scramble) tournament. All players tee off, the team selects the best shot, and all play from that spot. Each player's drive must be used at least ${event.required_drives_per_player} times during the round.` :
  `This is a ${event.format} tournament with ${event.team_size || 4} players per team.`
}

## Entry Fees
- **Individual Entry:** $${event.entry_fee_individual || '0'}
- **Team Entry:** $${event.entry_fee_team || '0'}
- **Includes:** ${event.entry_includes || 'Green fee, cart, range balls, prizes'}

## Competition
- **Type:** ${event.competition_type === 'both' ? 'Gross and Net' : event.competition_type === 'gross' ? 'Gross Only' : 'Net Only'}
- **Flights:** ${event.use_flights ? 'Yes' : 'No'}
- **Handicap Method:** ${event.team_handicap_method}

## Timeline
- ${event.checkin_open_time || '7:00 AM'} - Check-in opens
- ${event.start_time || '8:00 AM'} - Shotgun start
- Immediately following - Scoring and awards

## Side Games
${event.skins_enabled ? `- Skins Game ($${event.skins_entry_fee || '0'} per team)` : ''}
${event.ctp_enabled ? '- Closest to the Pin' : ''}
${event.long_drive_enabled ? '- Long Drive' : ''}
${event.straight_drive_enabled ? '- Straight Drive' : ''}
${event.longest_putt_enabled ? '- Longest Putt' : ''}
${event.mulligans_enabled ? `- Mulligans ($${event.mulligan_price || '0'} for ${event.mulligan_limit || 2})` : ''}
`;
}

function generateRulesDocument(event) {
  const isScramble = event.format === 'Captains Choice';
  
  return `
# ${event.name || 'Golf Outing'} - Official Rules & Format

${isScramble ? `
## SCRAMBLE FORMAT RULES

### How to Play
1. **All players tee off** on every hole
2. **Team selects the best ball** after each shot
3. **All players play from that spot** (within ${event.lie_improvement_distance})
4. **Continue until holed**

### Required Tee Shots
- Each player's drive must be used at least **${event.required_drives_per_player} times** during the 18-hole round
- If requirement is not met: **${event.penalty_missing_drives}-stroke penalty** added to final score

## LIES & PLACEMENT

### Ball Placement (Scramble)
- Place ball within **${event.lie_improvement_distance}** of selected spot
- ${event.same_cut_requirement ? 'Must remain in same cut of grass (fairway to fairway, rough to rough)' : 'Can be placed in any cut'}
- Never closer to the hole

### Bunkers
- ${event.bunker_rake_and_place ? 'Rake and place' : 'Must play from original lie'}
` : `
## ${event.format.toUpperCase()} FORMAT

${event.format === 'Best Ball' ? 'Each player plays their own ball. The lowest score on each hole counts as the team score.' : ''}
${event.format === 'Alternate Shot' ? 'Team members alternate hitting shots. Player A tees off on odd holes, Player B on even holes.' : ''}
${event.format === 'Stroke Play' ? 'Individual stroke play. Each player plays their own ball and records their own score.' : ''}
`}

### Preferred Lies
- ${event.lift_clean_place ? `Lift, clean, and place in effect on ${event.lift_clean_place_areas}` : 'Play the ball as it lies'}

## OUT OF BOUNDS & LOST BALLS

${event.ob_rule === 'stroke_and_distance' ? '- Standard stroke and distance penalty applies' : ''}
${event.ob_rule === 'lateral_drop' ? '- Drop laterally with 1-stroke penalty' : ''}
${event.e5_local_rule ? '- E-5 Local Rule: Drop with 2-stroke penalty where ball went OB/lost' : ''}

## PUTTING

### Gimmes
- ${event.gimme_allowed ? `Putts inside ${event.gimme_distance} may be conceded` : 'All putts must be holed'}

## MAXIMUM SCORE
- ${event.max_score_rule === 'net_double_bogey' ? 'Net double bogey per hole' : event.max_score_rule === 'double_bogey' ? 'Double bogey per hole' : 'No maximum'}

## PACE OF PLAY
- Maximum **${event.max_search_time} minutes** to search for lost balls
- ${event.ready_golf ? 'Ready golf encouraged' : 'Play according to honors'}
- Keep pace with group ahead

## HANDICAPS

### Handicap Basis
- ${event.handicap_basis === 'USGA' ? 'USGA Handicap Index' : event.handicap_basis === 'league' ? 'League handicap' : 'Captains estimate for players without official handicap'}

### Team Handicap Calculation
- Method: ${event.team_handicap_method}
${event.team_handicap_percentages ? `- Percentages: ${event.team_handicap_percentages}` : ''}

## SCORING & COMPETITION

### Format
- ${event.competition_type === 'both' ? 'Both gross and net scores count for prizes' : event.competition_type === 'gross' ? 'Gross scores only' : 'Net scores only'}

### Flights
- ${event.use_flights ? `Teams divided into flights by ${event.flight_method}` : 'Single flight for all teams'}

### Tiebreakers
- ${event.tiebreak_method === 'matchback' ? `Card matchback: ${event.tiebreak_order}` : ''}
- ${event.sudden_death ? 'Sudden death playoff if still tied' : 'Prize shared if still tied'}

## SIDE GAMES

${event.skins_enabled ? `### Skins
- **Type:** ${event.skins_type}
- **Entry Fee:** $${event.skins_entry_fee || '0'} per team
- Carryovers apply; shared if multiple winners on hole
` : ''}

${event.ctp_enabled ? `### Closest to the Pin
- **Holes:** ${event.ctp_holes || 'TBD'}
- **Categories:** ${event.ctp_categories || 'Overall'}
- Mark your ball before measuring
` : ''}

${event.long_drive_enabled ? `### Long Drive
- **Holes:** ${event.long_drive_holes || 'TBD'}
- **Categories:** ${event.long_drive_categories || 'Overall'}
- Must be in the fairway
` : ''}

${event.mulligans_enabled ? `### Mulligans
- **Price:** $${event.mulligan_price || '0'} for ${event.mulligan_limit || 2} mulligans
- **Use:** ${event.mulligan_use === 'tee_only' ? 'Tee shots only' : 'Anywhere'}
- Declare before hitting
` : ''}

## ETIQUETTE & SAFETY
- Repair divots and ball marks
- Keep carts on path where indicated
- Stay off greens and tees with carts
- Be courteous to other groups
- Have fun!
`;
}

function generateStarterScript(event) {
  const isScramble = event.format === 'Captains Choice';
  
  return `
# Starter Script - ${event.name || 'Golf Outing'}

Good morning everyone! Welcome to ${event.name || 'our golf outing'}!

## FORMAT
${isScramble ? `
We're playing a **${event.team_size}-person Captain's Choice scramble** today. Here's how it works:
- Everyone tees off
- Pick the best shot
- Everyone plays from there
- Each player's drive must be used at least **${event.required_drives_per_player} times**
` : `
We're playing **${event.format}** today with ${event.team_size || 4}-person teams.
${event.format === 'Best Ball' ? '- Each player plays their own ball\n- Lowest score counts for the team' : ''}
${event.format === 'Alternate Shot' ? '- Partners alternate hitting shots\n- One ball per team' : ''}
${event.format === 'Stroke Play' ? '- Individual play\n- Everyone plays their own ball' : ''}
`}

## KEY RULES

${isScramble ? `
### Ball Placement (Scramble)
- Within **${event.lie_improvement_distance}** of selected spot
- ${event.same_cut_requirement ? 'Same cut of grass' : 'Any cut'}
- Never closer to hole
` : ''}

### Special Conditions
- ${event.lift_clean_place ? `Lift, clean, and place on ${event.lift_clean_place_areas}` : 'Play it as it lies'}
- ${event.gimme_allowed ? `Gimmes inside ${event.gimme_distance}` : 'Hole everything out'}
- ${event.bunker_rake_and_place ? 'Rake and place in bunkers' : 'Play bunkers as they lie'}

### Out of Bounds
- ${event.ob_rule === 'stroke_and_distance' ? 'Stroke and distance' : event.e5_local_rule ? 'E-5 Rule: drop with 2-stroke penalty' : 'Lateral drop with 1-stroke penalty'}

## PACE OF PLAY
- Keep up with the group ahead
- ${event.ready_golf ? 'Ready golf - hit when ready' : 'Play honors'}
- Maximum **${event.max_search_time} minutes** for lost balls
- Let faster groups play through if you fall behind

## COURSE CONDITIONS
- Cart path only where marked
- Stay off tees and greens
- Repair divots and ball marks

## SIDE GAMES
${event.ctp_enabled ? `- Closest to Pin on holes ${event.ctp_holes || 'TBD'}` : ''}
${event.long_drive_enabled ? `- Long Drive on holes ${event.long_drive_holes || 'TBD'}` : ''}
${event.skins_enabled ? '- Skins game in effect' : ''}

## AFTER YOUR ROUND
- Sign and verify your scorecard
- Turn in card at ${event.scoring_method === 'physical' ? 'the scoring table' : 'the clubhouse'}
- Enjoy food and beverages
- Stick around for awards!

## QUESTIONS?
If you have any rules questions during play, please ask a course marshal or call the pro shop.

**Have a great round and good luck!**
`;
}

function generateScorecardTemplate(event) {
  return `
# SCORECARD - ${event.name || 'Golf Outing'}

## Team Information
- **Team Name:** _________________
- **Team Number:** _____
- **Flight:** _____

## Players
1. _________________________ (HCP: _____)
2. _________________________ (HCP: _____)
3. _________________________ (HCP: _____)
4. _________________________ (HCP: _____)

**Team Handicap:** _____

## Score

| Hole | Par | Yardage | Strokes | Drive Used |
|------|-----|---------|---------|------------|
| 1    |     |         |         |            |
| 2    |     |         |         |            |
| 3    |     |         |         |            |
| 4    |     |         |         |            |
| 5    |     |         |         |            |
| 6    |     |         |         |            |
| 7    |     |         |         |            |
| 8    |     |         |         |            |
| 9    |     |         |         |            |
| OUT  |     |         |         |            |
| 10   |     |         |         |            |
| 11   |     |         |         |            |
| 12   |     |         |         |            |
| 13   |     |         |         |            |
| 14   |     |         |         |            |
| 15   |     |         |         |            |
| 16   |     |         |         |            |
| 17   |     |         |         |            |
| 18   |     |         |         |            |
| IN   |     |         |         |            |
| TOTAL|     |         |         |            |

**Gross Score:** _____
**Team Handicap:** _____
**Net Score:** _____

## Side Games
- CTP Winners: _________________________
- Long Drive: __________________________
- Skins: _______________________________

## Signatures
All team members must sign to verify score:

1. _________________________ Date: _______
2. _________________________ Date: _______
3. _________________________ Date: _______
4. _________________________ Date: _______

**Turn in to scoring table immediately after finishing.**
`;
}

// ==================== MOBILE SCORING ENDPOINTS ====================

// Get team by access code
app.get('/api/mobile/team/:accessCode', async (req, res) => {
  try {
    const team = await db.get('SELECT * FROM teams WHERE access_code = ?', [req.params.accessCode]);
    if (!team) {
      return res.status(404).json({ error: 'Invalid access code' });
    }
    
    // Get event details
    const event = await db.get('SELECT * FROM events WHERE id = ?', [team.event_id]);
    
    // Get team players
    const players = await db.all('SELECT * FROM players WHERE team_id = ?', [team.id]);
    
    // Get all scores for this team
    const scores = await db.all('SELECT * FROM scores WHERE team_id = ? ORDER BY hole_number', [team.id]);
    
    res.json({ team, event, players, scores });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Update score from mobile (with audit trail)
app.put('/api/mobile/score', async (req, res) => {
  try {
    const { team_id, hole_number, strokes, drive_used_player_id, changed_by } = req.body;
    
    // Get existing score
    const existingScore = await db.get(
      'SELECT * FROM scores WHERE team_id = ? AND hole_number = ?',
      [team_id, hole_number]
    );
    
    // Create audit entry
    const auditId = uuidv4();
    await db.run(
      `INSERT INTO score_audit (id, team_id, hole_number, old_strokes, new_strokes, 
       old_drive_used_player_id, new_drive_used_player_id, changed_by, change_source) 
       VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
      [
        auditId,
        team_id,
        hole_number,
        existingScore?.strokes || null,
        strokes,
        existingScore?.drive_used_player_id || null,
        drive_used_player_id || null,
        changed_by || 'Team',
        'mobile'
      ]
    );
    
    // Update or insert score
    if (existingScore) {
      await db.run(
        'UPDATE scores SET strokes = ?, drive_used_player_id = ? WHERE team_id = ? AND hole_number = ?',
        [strokes, drive_used_player_id, team_id, hole_number]
      );
    } else {
      const scoreId = uuidv4();
      await db.run(
        'INSERT INTO scores (id, team_id, hole_number, strokes, drive_used_player_id) VALUES (?, ?, ?, ?, ?)',
        [scoreId, team_id, hole_number, strokes, drive_used_player_id]
      );
    }
    
    // Calculate total scores
    const allScores = await db.all('SELECT * FROM scores WHERE team_id = ?', [team_id]);
    const grossScore = allScores.reduce((sum, s) => sum + (s.strokes || 0), 0);
    
    // Update team totals
    await db.run('UPDATE teams SET gross_score = ? WHERE id = ?', [grossScore, team_id]);
    
    res.json({ success: true, grossScore });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Generate access code for team
app.post('/api/teams/:id/generate-code', async (req, res) => {
  try {
    const accessCode = Math.random().toString(36).substring(2, 8).toUpperCase();
    await db.run('UPDATE teams SET access_code = ? WHERE id = ?', [accessCode, req.params.id]);
    res.json({ accessCode });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== LEADERBOARD ENDPOINTS ====================

// Get live leaderboard for an event
app.get('/api/events/:eventId/leaderboard', async (req, res) => {
  try {
    const teams = await db.all(
      `SELECT t.*, 
        (SELECT COUNT(*) FROM scores WHERE team_id = t.id AND strokes IS NOT NULL) as holes_completed
       FROM teams t 
       WHERE t.event_id = ? 
       ORDER BY t.flight_number ASC, t.gross_score ASC, t.team_name ASC`,
      [req.params.eventId]
    );
    
    // Get player count for each team
    for (let team of teams) {
      const players = await db.all('SELECT first_name, last_name FROM players WHERE team_id = ?', [team.id]);
      team.players = players;
    }
    
    res.json(teams);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Assign teams to flights based on scores
app.post('/api/events/:eventId/assign-flights', async (req, res) => {
  try {
    const event = await db.get('SELECT * FROM events WHERE id = ?', [req.params.eventId]);
    if (!event) {
      return res.status(404).json({ error: 'Event not found' });
    }

    const numberOfFlights = event.number_of_flights || 1;
    
    // Get all teams with scores, sorted by gross score (best to worst)
    const teams = await db.all(
      `SELECT * FROM teams WHERE event_id = ? ORDER BY gross_score ASC NULLS LAST, team_name ASC`,
      [req.params.eventId]
    );

    if (teams.length === 0) {
      return res.json({ message: 'No teams to assign' });
    }

    // Divide teams evenly into flights using snake draft method
    // This ensures balanced flights (best team in flight 1, second best in flight 2, etc.)
    const teamsPerFlight = Math.ceil(teams.length / numberOfFlights);
    
    for (let i = 0; i < teams.length; i++) {
      // Snake pattern: 1,2,3,3,2,1,1,2,3...
      const round = Math.floor(i / numberOfFlights);
      let flightNumber;
      
      if (round % 2 === 0) {
        // Even rounds: assign forward (1,2,3)
        flightNumber = (i % numberOfFlights) + 1;
      } else {
        // Odd rounds: assign backward (3,2,1)
        flightNumber = numberOfFlights - (i % numberOfFlights);
      }
      
      await db.run(
        'UPDATE teams SET flight_number = ?, flight = ? WHERE id = ?',
        [flightNumber, `Flight ${flightNumber}`, teams[i].id]
      );
    }

    res.json({ 
      success: true, 
      message: `Assigned ${teams.length} teams to ${numberOfFlights} flights`,
      teamsPerFlight: teamsPerFlight
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Calculate suggested prize distribution across flights
app.post('/api/events/:eventId/calculate-prizes', async (req, res) => {
  try {
    const event = await db.get('SELECT * FROM events WHERE id = ?', [req.params.eventId]);
    if (!event) {
      return res.status(404).json({ error: 'Event not found' });
    }

    const { totalPurse, placesToPay } = req.body;
    const numberOfFlights = event.number_of_flights || 1;
    
    // Get team count
    const teams = await db.all('SELECT * FROM teams WHERE event_id = ?', [req.params.eventId]);
    const totalTeams = teams.length;
    
    if (totalTeams === 0) {
      return res.json({ 
        error: 'No teams in event',
        distribution: []
      });
    }

    // Calculate teams per flight
    const teamsPerFlight = Math.ceil(totalTeams / numberOfFlights);
    
    // Standard payout percentages (adjust based on places to pay)
    const payoutPercentages = {
      1: [100],
      2: [60, 40],
      3: [50, 30, 20],
      4: [40, 30, 20, 10],
      5: [35, 25, 20, 12, 8]
    };
    
    const places = Math.min(placesToPay || 3, teamsPerFlight);
    const percentages = payoutPercentages[places] || payoutPercentages[3];
    
    // Calculate prize per flight
    const prizePerFlight = totalPurse / numberOfFlights;
    
    // Build distribution for each flight
    const distribution = [];
    
    for (let flight = 1; flight <= numberOfFlights; flight++) {
      const flightPrizes = [];
      let flightTotal = 0;
      
      percentages.forEach((pct, index) => {
        const rawAmount = (prizePerFlight * pct) / 100;
        // Round to nearest $5 for even amounts
        const roundedAmount = Math.floor(rawAmount / 5) * 5;
        flightPrizes.push({
          place: index + 1,
          percentage: pct,
          amount: roundedAmount
        });
        flightTotal += roundedAmount;
      });
      
      distribution.push({
        flight: flight,
        flightName: `Flight ${flight}`,
        prizes: flightPrizes,
        flightTotal: flightTotal,
        teamsInFlight: teamsPerFlight
      });
    }
    
    // Calculate totals
    const totalAwarded = distribution.reduce((sum, f) => sum + f.flightTotal, 0);
    const leftover = totalPurse - totalAwarded;
    
    res.json({
      success: true,
      totalPurse: totalPurse,
      numberOfFlights: numberOfFlights,
      totalTeams: totalTeams,
      teamsPerFlight: teamsPerFlight,
      placesToPay: places,
      distribution: distribution,
      totalAwarded: totalAwarded,
      leftover: leftover
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ==================== AUDIT ENDPOINTS ====================

// Get audit history for a team
app.get('/api/teams/:teamId/audit', async (req, res) => {
  try {
    const audit = await db.all(
      'SELECT * FROM score_audit WHERE team_id = ? ORDER BY timestamp DESC',
      [req.params.teamId]
    );
    res.json(audit);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Get audit history for an event
app.get('/api/events/:eventId/audit', async (req, res) => {
  try {
    const audit = await db.all(
      `SELECT sa.*, t.team_name, t.team_number 
       FROM score_audit sa
       JOIN teams t ON sa.team_id = t.id
       WHERE t.event_id = ?
       ORDER BY sa.timestamp DESC`,
      [req.params.eventId]
    );
    res.json(audit);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Start server
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
